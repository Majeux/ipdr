#ifndef CLI_H
#define CLI_H

#include "io.h"
#include "logger.h"
#include "tactic.h"

#include <cxxopts.hpp>
#include <fmt/core.h>
#include <ostream>
#include <string>
#include <variant>

namespace my::cli
{
  using namespace cxxopts;
  using namespace my::io;

  namespace fs = ghc::filesystem;

  class ArgumentList;

  namespace graph_source
  {
    struct BenchFile
    {
    };

    struct Hop
    {
      unsigned bits;
      unsigned mod;
    };

    struct tfcFile
    {
    };
  } // namespace graph_source

  namespace model_type
  {
    using namespace graph_source;

    struct Pebbling
    {
      std::optional<unsigned> max_pebbles; // starting value for constraint
      std::variant<BenchFile, Hop, tfcFile> model;
    };

    struct Peterson
    {
      unsigned start;
      unsigned max;
    };

    struct model_t_string_visitor
    {
      std::string operator()(const Pebbling& a) const;
      std::string operator()(const Peterson& a) const;
    };

    std::string to_string(const std::variant<Pebbling, Peterson>& m);
  } // namespace model_type

  namespace algo
  {
    using namespace model_type;

    struct PDR
    {
      std::variant<Pebbling, Peterson> model;
    };

    struct IPDR
    {
      std::variant<Pebbling, Peterson> model;
    };

    struct Bounded
    {
      Pebbling model;
    };

    struct algo_string_visitor
    {
      std::string operator()(const PDR& a) const;
      std::string operator()(const IPDR& a) const;
      std::string operator()(const Bounded& a) const;
    };

    std::string to_string(const std::variant<PDR, IPDR, Bounded>& a);
    std::variant<PDR, IPDR, Bounded> get_algo(const ArgumentList& args);
  } // namespace algo

  struct Experiment
  {
    std::variant<algo::IPDR, algo::Bounded> type;
    unsigned repetitions;
  };

  enum class ModelType
  {
    none,
    tfc,
    bench,
    hoperator
  };

  class ArgumentList
  {
   public:
    using Algo_var =
        std::variant<algo::Bounded, algo::Pebbling, algo::Peterson>;

    OutLvl verbosity;
    // the way pdr is run
    pdr::Tactic tactic = pdr::Tactic::undef;
    // if given: run an experiment in with this many samples
    std::optional<unsigned> exp_sample;
    // comparison run for optimizer experiments
    bool exp_control;
    ModelType model;
    // folder that contains the model_name file
    fs::path bench_folder;
    // file_name (without extension) for the model
    std::string model_name;
    // H-operator model, instead of reading a graph
    // Hop hop;
    std::optional<std::string> out; // filename to redirect logging out messages

    std::optional<unsigned>
        starting_value; // the constraint on no. marked n_nodes

    // run options
    bool rand; // use a seed for the solver. generated by time(0)
    std::optional<unsigned> seed; // the seed for the solver
    bool tseytin; // encode pebbling::Model transition using tseyting enconding

    bool onlyshow; // only read in and produce the model image and description

    bool bounded;
    bool peter;

    Algo_var algorithm;
    Experiment experiment;
    std::variant<bool, unsigned> r_seed;

    bool _failed = false;

    ArgumentList(int argc, char* argv[]);
    void show_header(std::ostream& out) const;
    const FolderStructure make_folders() const;
    std::string file_name() const;
    std::string run_folder_name() const;
    fs::path create_model_dir() const;
    fs::path setup_run_path() const;

   private:
    // cli names
    inline static const std::string s_pdr     = "pdr";
    inline static const std::string s_ipdr    = "ipdr";
    inline static const std::string s_bounded = "bounded";

    inline static const std::string s_pebbling = "pebbling";
    inline static const std::string s_peter    = "peterson";

    inline static const std::string s_exp     = "experiment";
    inline static const std::string s_control = "control";

    inline static const std::string s_pebbles = "pebbles";
    inline static const std::string s_procs   = "processes";

    inline static const std::string s_dir   = "dir";
    inline static const std::string s_bench = "bench";
    inline static const std::string s_tfc   = "tfc";
    inline static const std::string s_hop   = "hop";

    inline static const std::string s_rand    = "rand";
    inline static const std::string s_seed    = "seed";
    inline static const std::string s_tseytin = "tseytin";
    inline static const std::string s_show    = "show-only";

    inline static const std::string s_verbose = "verbose";
    inline static const std::string s_whisper = "whisper";
    inline static const std::string s_silent  = "silent";

    // constructor helpers
    Options make_options(std::string name);
    void parse_verbosity(const ParseResult& clresult);
    void parse_tactic(const ParseResult& clresult);
    void parse_model(const ParseResult& clresult);
  };
} // namespace my::cli
#endif // CLI_H
